#
# Copyright The NOMAD Authors.
#
# This file is part of NOMAD. See https://nomad-lab.eu for further info.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

from datetime import datetime
from typing import TYPE_CHECKING

import numpy as np
import plotly.graph_objects as go
from nomad.datamodel.data import ArchiveSection, EntryData
from nomad.datamodel.metainfo.basesections import Measurement, MeasurementResult
from nomad.datamodel.metainfo.plot import PlotlyFigure, PlotSection
from nomad.metainfo import Datetime, Package, Quantity, Section, SubSection

from nomad_ikz_omega_theta_xrd.schema_packages.omegathetaxrdreader import (
    extract_data_and_metadata,
)

if TYPE_CHECKING:
    from nomad.datamodel.datamodel import EntryArchive
    from structlog.stdlib import BoundLogger

m_package = Package(name='Omega Theta XRD')


class ScanCurve(PlotSection, ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    name = Quantity(
        type=str,
        description='L or R',
        a_eln={'component': 'StringEditQuantity'},
        name=None,
    )
    omega = Quantity(
        type=np.float64,
        description='Omega scan values',
        # a_eln={'component': 'NumberEditQuantity'},
        shape=['*'],
        unit='\u00b0',
    )
    intensity = Quantity(
        type=np.float64,
        description='Intensity values',
        # a_eln={'component': 'NumberEditQuantity'},
        shape=['*'],
        # unit='\u00b0',
        a_plot={'x': 'omega', 'y': 'intensity'},
    )

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `ScanCurve` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        super().normalize(archive, logger)


class ParameterList(MeasurementResult, PlotSection, ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section(a_eln=dict(overview=True))
    name = Quantity(
        type=str,
        description='Name of the scan generated from the X-Y position',
        a_eln={'component': 'StringEditQuantity'},
    )
    XPos = Quantity(
        type=int,
        description='XPos',
        a_eln={'component': 'NumberEditQuantity'},
    )
    YPos = Quantity(
        type=int,
        description='YPos',
        a_eln={'component': 'NumberEditQuantity'},
    )
    Tilt = Quantity(
        type=np.float64,
        description='Tilt',
        a_eln={'component': 'NumberEditQuantity'},
        unit='\u00b0',
    )
    Tilt_direction = Quantity(
        type=np.float64,
        description='Tilt direction',
        a_eln={'component': 'NumberEditQuantity'},
        unit='\u00b0',
    )
    Component_0 = Quantity(
        type=np.float64,
        description='Component 0',
        a_eln={'component': 'NumberEditQuantity'},
        unit='\u00b0',
    )
    Component_90 = Quantity(
        type=np.float64,
        description='Component 90',
        a_eln={'component': 'NumberEditQuantity'},
        unit='\u00b0',
    )
    Reference_offset = Quantity(
        type=np.float64,
        description='Reference offset',
        a_eln={'component': 'NumberEditQuantity'},
        unit='\u00b0',
    )
    Reference_axis = Quantity(
        type=str,
        description='Reference axis',
        a_eln={'component': 'StringEditQuantity'},
    )
    Scan_Curves = SubSection(
        section_def=ScanCurve,
        repeats=True,
    )

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `ParameterList` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        super().normalize(archive, logger)
        fig = go.Figure()
        fig.add_trace(
            go.Scatter(
                x=self.Scan_Curves[0].omega,
                y=self.Scan_Curves[0].intensity,
                mode='lines',
                name='Omega R',
            )
        )
        fig.add_trace(
            go.Scatter(
                x=self.Scan_Curves[1].omega,
                y=self.Scan_Curves[1].intensity,
                mode='lines',
                name='Omega L',
            )
        )

        fig.update_layout(
            height=400,
            width=716,
            title_text='Omega Theta XRD',
            showlegend=True,
            legend=dict(yanchor='top', y=0.99, xanchor='left', x=0.01),
        )
        # self.figures = []
        self.figures.append(PlotlyFigure(label='figure 2', figure=fig.to_plotly_json()))


class OmegaThetaXRD(Measurement, EntryData, ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    scan_recipe_name = Quantity(
        type=str,
        description='Omega scan recipe name',
        a_eln={'component': 'StringEditQuantity'},
    )
    data_file = Quantity(
        type=str,
        description='Data file *.xrd containing the XRD data.',
        a_eln={'component': 'FileEditQuantity'},
    )
    time_stamp = Quantity(
        type=Datetime,
        a_eln={'component': 'DateTimeEditQuantity'},
    )
    results = SubSection(
        section_def=ParameterList,
        repeats=True,
    )

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `OmegaThetaXRD` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        super().normalize(archive, logger)
        if self.data_file is not None:
            read_function = extract_data_and_metadata
            # write_function = self.get_write_functions()
            # if read_function is None or write_function is None:
            #     logger.warn(
            #         f'No compatible reader found for the file: "{self.data_file}".'
            #     )
            # else:
            with archive.m_context.raw_file(self.data_file) as file:
                xrd_dict = read_function(file.name)
                #    raman_dict = read_function(file.name)  # , logger)
                # write_function(raman_dict, archive, logger)
                self.name = xrd_dict.get('metadata').get('Info').get('Name')
                self.time_stamp = datetime.strptime(
                    xrd_dict.get('metadata').get('Info').get('TimeStamp'),
                    '%m/%d/%Y %H:%M:%S',
                )
                self.scan_recipe_name = (
                    xrd_dict.get('metadata').get('Info').get('RecipeName')
                )
                results = ParameterList()
                results.name = (
                    xrd_dict.get('metadata').get('Info').get('XPos')
                    + '-'
                    + xrd_dict.get('metadata').get('Info').get('YPos')
                )
                results.XPos = int(
                    xrd_dict.get('metadata')
                    .get('Result')
                    .get('ParameterList')
                    .get('Parameter')[3]
                    .get('Value')
                )
                results.YPos = int(
                    xrd_dict.get('metadata')
                    .get('Result')
                    .get('ParameterList')
                    .get('Parameter')[4]
                    .get('Value')
                )
                results.Tilt = float(
                    xrd_dict.get('metadata')
                    .get('Result')
                    .get('ParameterList')
                    .get('Parameter')[8]
                    .get('Value')
                )
                results.Tilt_direction = float(
                    xrd_dict.get('metadata')
                    .get('Result')
                    .get('ParameterList')
                    .get('Parameter')[9]
                    .get('Value')
                )
                results.Component_0 = float(
                    xrd_dict.get('metadata')
                    .get('Result')
                    .get('ParameterList')
                    .get('Parameter')[12]
                    .get('Value')
                )
                results.Component_90 = float(
                    xrd_dict.get('metadata')
                    .get('Result')
                    .get('ParameterList')
                    .get('Parameter')[13]
                    .get('Value')
                )
                results.Reference_offset = float(
                    xrd_dict.get('metadata')
                    .get('Result')
                    .get('ParameterList')
                    .get('Parameter')[14]
                    .get('Value')
                )
                results.Reference_axis = (
                    xrd_dict.get('metadata')
                    .get('Result')
                    .get('ParameterList')
                    .get('Parameter')[15]
                    .get('Value')
                )

                scan_r = ScanCurve()
                scan_r.name = (
                    xrd_dict.get('scans')
                    .get('Scan')
                    .get('ScanCurves')
                    .get('ScanCurve')[0]
                    .get('Name')
                )

                input_str = (
                    xrd_dict.get('scans')
                    .get('Scan')
                    .get('ScanCurves')
                    .get('ScanCurve')[0]
                    .get('text')
                )
                scanarray_omega = []
                scanarray_intensity = []
                [
                    scanarray_omega.append(float(i.split(' ')[0]))
                    for i in input_str.split(';')
                    if i
                ]
                [
                    scanarray_intensity.append(float(i.split(' ')[1]))
                    for i in input_str.split(';')
                    if i
                ]
                # scan_r = ScanCurve()
                scan_r.omega = scanarray_omega
                scan_r.intensity = scanarray_intensity

                scan_l = ScanCurve()
                scan_l.name = (
                    xrd_dict.get('scans')
                    .get('Scan')
                    .get('ScanCurves')
                    .get('ScanCurve')[1]
                    .get('Name')
                )

                input_str = (
                    xrd_dict.get('scans')
                    .get('Scan')
                    .get('ScanCurves')
                    .get('ScanCurve')[1]
                    .get('text')
                )
                scanarray_omega = []
                scanarray_intensity = []
                [
                    scanarray_omega.append(float(i.split(' ')[0]))
                    for i in input_str.split(';')
                    if i
                ]
                [
                    scanarray_intensity.append(float(i.split(' ')[1]))
                    for i in input_str.split(';')
                    if i
                ]
                # scan_r = ScanCurve()
                scan_l.omega = scanarray_omega
                scan_l.intensity = scanarray_intensity
                # [scan_r.omega.append(i.split(' ')[0]) for i in input_str.split(';')]

                results.Scan_Curves = [scan_r, scan_l]
                results.normalize(archive, logger)
                self.results = [results]
        if not self.results:
            return
        # figure1 = px.line(
        #     x=self.results[0].Scan_Curves[0].omega,
        #     y=self.results[0].Scan_Curves[0].intensity,
        #     title='Raman Spectrum',
        #     labels={
        #         'x': 'Wavenumber [1/cm]',
        #         'y': 'Intensity [a.u.]',
        #         'species': 'Species of Iris',
        #     },
        # )
        # self.figures.append(
        #     PlotlyFigure(label='figure 1', index=1, figure=figure1.to_plotly_json())
        # )


m_package.__init_metainfo__()
