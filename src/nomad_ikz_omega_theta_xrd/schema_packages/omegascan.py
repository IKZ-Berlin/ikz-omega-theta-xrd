#
# Copyright The NOMAD Authors.
#
# This file is part of NOMAD. See https://nomad-lab.eu for further info.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

from datetime import datetime
from typing import TYPE_CHECKING

import matplotlib.pyplot as plt
import numpy as np
import plotly.colors as pc
import plotly.figure_factory as ff
import plotly.graph_objects as go
from nomad.datamodel.data import ArchiveSection, EntryData
from nomad.datamodel.metainfo.basesections import (
    CompositeSystemReference,
    Instrument,
    InstrumentReference,
    Measurement,
    MeasurementResult,
)
from nomad.datamodel.metainfo.plot import PlotlyFigure, PlotSection
from nomad.metainfo import MEnum, Package, Quantity, Section, SubSection

from nomad_ikz_omega_theta_xrd.schema_packages.omegathetaxrdreader import (
    extract_data_and_metadata,
    extract_general_info,
    extract_parameter_list,
    extract_scan_data,
)
from nomad_ikz_omega_theta_xrd.schema_packages.utils import create_archive

if TYPE_CHECKING:
    from nomad.datamodel.datamodel import EntryArchive
    from structlog.stdlib import BoundLogger

m_package = Package(name='Omega Theta XRD')


class OmegaThetaXRDInstrument(Instrument, EntryData, ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    instrument_name = Quantity(
        type=str,
        description='Name of the instrument used.',
        default='Freiberger Omega Theta XRD',
    )
    lab_id = Quantity(
        type=str,
        description='Identifier for the instrument.',
        default='26-0019',
        label='serial_number',
    )
    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `OmegaThetaXRDInstrument` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        super().normalize(archive, logger)



class OmegaThetaXRDInstrumentReference(InstrumentReference):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    reference = Quantity(
        type=OmegaThetaXRDInstrument,
        a_eln={
            'component': 'ReferenceEditQuantity',
            'label': 'omega_theta_xrd_instrument',
        },
    )
    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `OmegaThetaXRDInstrumentReference` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        super().normalize(archive, logger)


class ScanCurve(PlotSection, ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    name = Quantity(
        type=str,
        description='L or R',
        a_eln={'component': 'StringEditQuantity'},
        name=None,
    )
    omega = Quantity(
        type=np.float64,
        description='Omega scan values',
        # a_eln={'component': 'NumberEditQuantity'},
        shape=['*'],
        unit='\u00b0',
    )
    intensity = Quantity(
        type=np.float64,
        description='Intensity values',
        # a_eln={'component': 'NumberEditQuantity'},
        shape=['*'],
        # unit='\u00b0',
        a_plot={'x': 'omega', 'y': 'intensity'},
    )

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `ScanCurve` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        super().normalize(archive, logger)


class ParameterList(MeasurementResult, PlotSection, ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section(
        a_eln=dict()
    )  # overview=True , put back if plot table is not looking good
    name = Quantity(
        type=str,
        description='Name of the scan generated from the X-Y position',
        a_eln={'component': 'StringEditQuantity'},
    )
    x_pos = Quantity(
        type=np.float64,
        description='XPos',
        a_eln={'component': 'NumberEditQuantity'},
    )
    y_pos = Quantity(
        type=np.float64,
        description='YPos',
        a_eln={'component': 'NumberEditQuantity'},
    )
    tilt = Quantity(
        type=np.float64,
        description='Tilt',
        a_eln={'component': 'NumberEditQuantity'},
        unit='\u00b0',
    )
    tilt_direction = Quantity(
        type=np.float64,
        description='Tilt direction',
        a_eln={'component': 'NumberEditQuantity'},
        unit='\u00b0',
    )
    component_0 = Quantity(
        type=np.float64,
        description='Component 0',
        a_eln={'component': 'NumberEditQuantity'},
        # unit='\u00b0',
    )
    component_90 = Quantity(
        type=np.float64,
        description='Component 90',
        a_eln={'component': 'NumberEditQuantity'},
        # unit='\u00b0',
    )
    reference_offset = Quantity(
        type=np.float64,
        description='Reference offset',
        a_eln={'component': 'NumberEditQuantity'},
        # unit='\u00b0',
    )
    reference_axis = Quantity(
        type=str,
        description='Reference axis',
        a_eln={'component': 'StringEditQuantity'},
    )
    Scan_Curves = SubSection(
        section_def=ScanCurve,
        repeats=True,
    )
    show_polar_plot = Quantity(
        type=bool,
        description='Generate polar plot',
        a_eln={'component': 'BoolEditQuantity'},
    )

    def generate_scan_plot(self):
        fig = go.Figure()
        fig.add_trace(
            go.Scatter(
                x=self.Scan_Curves[0].omega,
                y=self.Scan_Curves[0].intensity,
                mode='lines',
                name='Omega R',
            )
        )
        fig.add_trace(
            go.Scatter(
                x=self.Scan_Curves[1].omega,
                y=self.Scan_Curves[1].intensity,
                mode='lines',
                name='Omega L',
            )
        )

        fig.update_layout(
            height=400,
            width=716,
            title_text='Omega Theta XRD',
            showlegend=True,
            legend=dict(yanchor='top', y=0.99, xanchor='left', x=0.01),
            template='plotly_white',
            hovermode='closest',
            dragmode='zoom',
            xaxis=dict(
                fixedrange=False,
                # autorange=True,
                title='Omega (°)',
            ),
            yaxis=dict(
                fixedrange=False,
                title='Intensity (a.u.)',
            ),
        )
        return PlotlyFigure(label='Omega Scans', figure=fig.to_plotly_json())

    def generate_stereographic_plot(self):
        # Werte für Tiltwinkel (Rho) und Azimut (Theta)
        rho = self.tilt.magnitude
        theta = self.tilt_direction.magnitude
        ref_axis = self.reference_axis

        # Stereographische Projektion mit Plotly erstellen
        fig_stereo = go.Figure(
            go.Scatterpolar(
                r=[0, rho],
                theta=[0, theta],
                mode='lines+markers',
                marker=dict(size=8),
            )
        )

        # Layout anpassen, 0 Grad auf 9 Uhr setzen
        fig_stereo.update_layout(
            polar=dict(
                angularaxis=dict(
                    rotation=180,  # Rotieren, um 0° auf 9 Uhr zu setzen
                    direction='clockwise',
                ),
                radialaxis=dict(
                    range=[0, np.ceil(rho * 10) / 10],  # Maximalen Radius anpassen
                    visible=True,
                ),
            ),
            showlegend=False,
            title='Stereographic Projection of the Tilt Angle',
            template='plotly_white',
            hovermode='closest',
            dragmode='zoom',
        )
        # Add a thick grey bar at the edge of the polar plot (around 0°)
        fig_stereo.add_shape(
            type='rect',  # Create a rectangle instead of a line for a thick bar
            x0=0.1,
            x1=0.11,  # Define width of the bar
            y0=0.2,
            y1=0.8,  # Full height of the plot area
            xref='paper',
            yref='paper',  # Reference to the full plot area
            fillcolor='grey',  # Color of the bar
            line=dict(color='grey', width=0),  # No outline for the rectangle
            opacity=0.7,  # Adjust the transparency if necessary
        )
        # Add text label "Reference Axis" near the 0° position
        fig_stereo.add_annotation(
            x=0.1,
            y=0.48,  # Slightly outside the 0° circle label
            text='(' + ref_axis + ')',
            showarrow=False,
            xref='paper',
            yref='paper',
            font=dict(size=12, color='black'),
        )

        return PlotlyFigure(
            label='Stereographic Projection', figure=fig_stereo.to_plotly_json()
        )

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `ParameterList` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        if self.show_polar_plot is True:
            self.figures.append(self.generate_stereographic_plot())

        super().normalize(archive, logger)


class Samples(CompositeSystemReference):
    m_def = Section(label='Sample', a_eln=dict(overview=True))


class SampleSpecifications(ArchiveSection):
    m_def = Section(a_eln=dict(overview=True))
    sample_preparation_status = Quantity(
        type=str,
        description='Status of the sample preparation',
        a_eln={'component': 'StringEditQuantity'},
    )
    sample_side_facing_down = Quantity(
        type=MEnum(['Al unten', 'N unten']),
        description='sample surface facing downwards',
        a_eln={'component': 'EnumEditQuantity'},
    )


class OmegaThetaXRD(Measurement, PlotSection, EntryData, ArchiveSection):
    """
    Class autogenerated from yaml schema.
    """

    m_def = Section()
    scan_recipe_name = Quantity(
        type=str,
        description='Omega scan recipe name',
        a_eln={'component': 'StringEditQuantity'},
    )
    data_file = Quantity(
        type=str,
        description='Data file *.xrd containing the XRD data.',
        a_eln={'component': 'FileEditQuantity'},
    )
    # time_stamp = Quantity(
    #     type=Datetime,
    #     a_eln={'component': 'DateTimeEditQuantity'},
    # )
    measurement_type = Quantity(
        type=MEnum(['single measurement', 'mapping']),
        description='Type of the measurement',
        a_eln={'component': 'EnumEditQuantity'},
    )
    wafer_diameter = Quantity(
        type=np.float64,
        description='The diameter of the wafer that is measured',
        a_eln={'component': 'NumberEditQuantity'},
        # unit='cm', ?
    )
    grid_size = Quantity(
        type=np.float64,
        description='Grid size of the mapping',
        a_eln={'component': 'NumberEditQuantity'},
        # unit='cm', ?
    )
    
    samples = SubSection(section_def=Samples, repeats=True)
    sample_specifications = SubSection(
        section_def=SampleSpecifications,
    )

    results = SubSection(
        section_def=ParameterList,
        repeats=True,
    )
    instruments = SubSection(
        section_def=OmegaThetaXRDInstrumentReference,
    )

    def generate_table_plot(self):
        # Extract the values for each column from all self.results
        x_pos_list = [f'{result.x_pos:.1f}' for result in self.results]
        y_pos_list = [f'{result.y_pos:.1f}' for result in self.results]
        tilt_list = [f'{result.tilt.magnitude:.3f}' for result in self.results]
        tilt_direction_list = [
            f'{result.tilt_direction.magnitude:.1f}' for result in self.results
        ]
        component_0_list = [f'{result.component_0:.3f}' for result in self.results]
        component_90_list = [f'{result.component_90:.3f}' for result in self.results]
        reference_offset_list = [
            f'{result.reference_offset:.3f}' for result in self.results
        ]
        reference_axis_list = [result.reference_axis for result in self.results]

        fig_table = go.Figure(
            data=[
                go.Table(
                    columnwidth=[1, 1, 1, 1.5, 2, 2, 1.8, 1.8],
                    header=dict(
                        values=[
                            'X Pos.',
                            'Y Pos.',
                            'Tilt',
                            'Tilt Direction',
                            'Component 0',
                            'Component 90',
                            'Reference Offset',
                            'Reference Axis',
                        ],
                        align='center',
                    ),
                    cells=dict(
                        values=[
                            x_pos_list,
                            y_pos_list,
                            tilt_list,
                            tilt_direction_list,
                            component_0_list,
                            component_90_list,
                            reference_offset_list,
                            reference_axis_list,
                        ],
                        align='center',
                    ),
                )
            ]
        )
        fig_table.update_layout(width=1000, height=200)
        fig_table.update_layout(
            margin=dict(l=1, r=1, t=1, b=1)  # Set left, right, top, bottom margins
        )
        return PlotlyFigure(label='Table', figure=fig_table.to_plotly_json())

    def normalize(self, archive: 'EntryArchive', logger: 'BoundLogger') -> None:
        """
        The normalizer for the `OmegaThetaXRD` class.

        Args:
            archive (EntryArchive): The archive containing the section that is being
            normalized.
            logger (BoundLogger): A structlog logger.
        """
        # super().normalize(archive, logger)

        if self.data_file is not None:
            # read_function = extract_data_and_metadata
            # write_function = self.get_write_functions()
            # if read_function is None or write_function is None:
            #     logger.warn(
            #         f'No compatible reader found for the file: "{self.data_file}".'
            #     )
            # else:
            with archive.m_context.raw_file(self.data_file) as file:
                xrd_dict = extract_data_and_metadata(file.name)
                #    raman_dict = read_function(file.name)  # , logger)
                # write_function(raman_dict, archive, logger)
                if (
                    extract_general_info(xrd_dict.get('Measurement', {}))['name']
                    != None
                ):
                    info_dict = extract_general_info(xrd_dict.get('Measurement', {}))
                    paramter_dict = extract_parameter_list(
                        xrd_dict.get('Measurement', {})
                    )
                    scan_dict = extract_scan_data(xrd_dict.get('Measurement', {}))

                    self.name = info_dict.get('name').split('_')[
                        0
                    ]  # should be original_name
                    self.lab_id = self.name
                    self.datetime = datetime.strptime(
                        info_dict.get('time_stamp'), '%m/%d/%Y %H:%M:%S'
                    )
                    self.scan_recipe_name = info_dict.get('scan_recipe_name')
                    self.measurement_type = 'single measurement'
                    if info_dict.get('wafer_diameter'):
                        self.wafer_diameter = float(info_dict.get('wafer_diameter'))
                    self.samples = []
                    if '-MI_' or '-XY_' in self.data_file:
                        sampleid = self.data_file.split('_')[0][:-3]
                    else:
                        sampleid = self.data_file
                    sample = Samples(lab_id=sampleid)
                    self.samples.append(sample)
                    samplespecs = SampleSpecifications()
                    if '-NU' in self.data_file:
                        samplespecs.sample_side_facing_down = 'N unten'
                    elif '-AU' in self.data_file:
                        samplespecs.sample_side_facing_down = 'Al unten'
                    sampleprep = ''
                    if '-AL' in self.data_file:
                        sampleprep += 'Al polar lapped, '
                    elif '-AP' in self.data_file:
                        sampleprep += 'Al polar polished, '
                    elif '-AS' in self.data_file:
                        sampleprep += 'Al polar sawed, '
                    if '-NL' in self.data_file:
                        sampleprep += 'N polar lapped'
                    elif '-NP' in self.data_file:
                        sampleprep += 'N polar polished'
                    elif '-NS' in self.data_file:
                        sampleprep += 'N polar sawed'
                    samplespecs.sample_preparation_status = sampleprep
                    self.sample_specifications = samplespecs

                    results = ParameterList()
                    results.name = info_dict.get('name')
                    results.x_pos = float(paramter_dict.get('xpos'))
                    results.y_pos = float(paramter_dict.get('ypos'))
                    results.tilt = float(paramter_dict.get('tilt'))
                    results.tilt_direction = float(paramter_dict.get('tilt_direction'))
                    results.component_0 = float(paramter_dict.get('component_0'))
                    results.component_90 = float(paramter_dict.get('component_90'))
                    results.reference_offset = float(
                        paramter_dict.get('reference_offset')
                    )
                    results.reference_axis = paramter_dict.get('reference_axis')
                    scan_r = ScanCurve()
                    scan_r.name = scan_dict.get('scan_r').get('name')
                    scan_r.omega = scan_dict.get('scan_r').get('omega')
                    scan_r.intensity = scan_dict.get('scan_r').get('intensity')
                    scan_l = ScanCurve()
                    scan_l.name = scan_dict.get('scan_l').get('name')
                    scan_l.omega = scan_dict.get('scan_l').get('omega')
                    scan_l.intensity = scan_dict.get('scan_l').get('intensity')
                    results.Scan_Curves = [scan_r, scan_l]
                    # results.normalize(archive, logger)
                    self.results = [results]

                    xrdinstrumentref = OmegaThetaXRDInstrumentReference()
                    xrdinstrumentref.lab_id = info_dict.get('device_serial_no')
                    xrdinstrumentref.normalize(archive, logger)
                    if xrdinstrumentref.reference is None:
                        xrdinstrument = OmegaThetaXRDInstrument(
                            lab_id=xrdinstrumentref.lab_id
                        )
                        #    self.instruments = [ramanspectrometer]

                        xrdinstrumentref.reference = create_archive(
                            xrdinstrument,
                            archive,
                            f'Freiberger_Omega_Theta_XRD_{xrdinstrumentref.lab_id}.archive.json',
                        )
                    self.instruments = [xrdinstrumentref]

                    self.figures = []

                    self.results[0].figures = []
                    self.results[0].figures.append(self.results[0].generate_scan_plot())

                    self.figures.append(self.generate_table_plot())

                    if self.results[0].tilt and self.results[0].tilt_direction:
                        self.figures.append(
                            self.results[0].generate_stereographic_plot()
                        )

                    self.figures.append(self.results[0].generate_scan_plot())

                elif (
                    extract_general_info(xrd_dict.get('MultiMeasurement', {}))['name']
                    != None
                ):
                    info_dict = extract_general_info(
                        xrd_dict.get('MultiMeasurement', {})
                    )

                    self.name = info_dict.get('name').split('_')[0]
                    self.lab_id = self.name
                    self.datetime = datetime.strptime(
                        info_dict.get('time_stamp'), '%m/%d/%Y %H:%M:%S'
                    )
                    self.scan_recipe_name = info_dict.get('scan_recipe_name')
                    self.measurement_type = 'mapping'
                    self.wafer_diameter = float(info_dict.get('wafer_diameter'))
                    self.grid_size = float(info_dict.get('grid_size'))
                    self.samples = []
                    if '-MI_' or '-XY_' in self.data_file:
                        sampleid = self.data_file.split('_')[0][:-3]
                    else:
                        sampleid = self.data_file
                    sample = Samples(lab_id=sampleid)
                    self.samples.append(sample)
                    samplespecs = SampleSpecifications()
                    if '-NU' in self.data_file:
                        samplespecs.sample_side_facing_down = 'N unten'
                    elif '-AU' in self.data_file:
                        samplespecs.sample_side_facing_down = 'Al unten'
                    sampleprep = ''
                    if '-AL' in self.data_file:
                        sampleprep += 'Al polar lapped, '
                    elif '-AP' in self.data_file:
                        sampleprep += 'Al polar polished, '
                    elif '-AS' in self.data_file:
                        sampleprep += 'Al polar sawed, '
                    if '-NL' in self.data_file:
                        sampleprep += 'N polar lapped'
                    elif '-NP' in self.data_file:
                        sampleprep += 'N polar polished'
                    elif '-NS' in self.data_file:
                        sampleprep += 'N polar sawed'
                    samplespecs.sample_preparation_status = sampleprep
                    self.sample_specifications = samplespecs
                    for measurement in (
                        xrd_dict.get('MultiMeasurement', {})
                        .get('Measurements', {})
                        .get('Measurement')
                    ):
                        info_dict = extract_general_info(measurement)
                        paramter_dict = extract_parameter_list(measurement)
                        # scan_dict = extract_scan_data(measurement)
                        results = ParameterList()
                        results.name = info_dict.get('name')
                        results.x_pos = float(paramter_dict.get('xpos'))
                        results.y_pos = float(paramter_dict.get('ypos'))
                        results.tilt = float(paramter_dict.get('tilt'))
                        results.tilt_direction = float(
                            paramter_dict.get('tilt_direction')
                        )
                        results.component_0 = float(paramter_dict.get('component_0'))
                        results.component_90 = float(paramter_dict.get('component_90'))
                        results.reference_offset = float(
                            paramter_dict.get('reference_offset')
                        )
                        results.reference_axis = paramter_dict.get('reference_axis')
                        # # scan_r = ScanCurve()
                        # # scan_r.name = scan_dict.get('scan_r').get('name')
                        # # scan_r.omega = scan_dict.get('scan_r').get('omega')
                        # # scan_r.intensity = scan_dict.get('scan_r').get('intensity')
                        # # scan_l = ScanCurve()
                        # # scan_l.name = scan_dict.get('scan_l').get('name')
                        # # scan_l.omega = scan_dict.get('scan_l').get('omega')
                        # # scan_l.intensity = scan_dict.get('scan_l').get('intensity')
                        # # results.Scan_Curves = [scan_r, scan_l]
                        # results.normalize(archive, logger)
                        self.results.append(results)

                        xrdinstrumentref = OmegaThetaXRDInstrumentReference()
                        xrdinstrumentref.lab_id = info_dict.get('device_serial_no')
                        xrdinstrumentref.normalize(archive, logger)
                        if xrdinstrumentref.reference is None:
                            xrdinstrument = OmegaThetaXRDInstrument(
                                lab_id=xrdinstrumentref.lab_id
                            )
                            #    self.instruments = [ramanspectrometer]

                            xrdinstrumentref.reference = create_archive(
                                xrdinstrument,
                                archive,
                                f'Freiberger_Omega_Theta_XRD_{xrdinstrumentref.lab_id}.archive.json',
                            )
                        self.instruments = [xrdinstrumentref]

                    if self.results != None:
                        # Extracting data for the plots
                        x_coords = [float(point['x_pos']) for point in self.results]
                        y_coords = [float(point['y_pos']) for point in self.results]
                        tilt_values = [
                            float(point['tilt'].magnitude) for point in self.results
                        ]
                        tilt_direction_values = [
                            float(point['tilt_direction'].magnitude)
                            for point in self.results
                        ]
                        component_0_values = [
                            float(point['component_0'])  # .magnitude)
                            for point in self.results
                        ]
                        component_90_values = [
                            float(point['component_90'])  # .magnitude)
                            for point in self.results
                        ]
                        reference_offset_values = [
                            float(point['reference_offset'])  # .magnitude)
                            for point in self.results
                        ]
                        # Function to normalize values and map to colors

                        def get_colors(values):
                            norm = plt.Normalize(min(values), max(values))
                            cmap = plt.cm.viridis
                            return [cmap(norm(value)) for value in values]

                        # def get_colors_pl(values):
                        #     norm = plt.Normalize(min(values), max(values))
                        #     colorscale = pc.get_colorscale('balance')
                        #     return [
                        #         pc.find_intermediate_color(
                        #             colorscale, intermed=norm(value), colortype='rgb'
                        #         )
                        #         for value in values
                        #     ]
                        def get_colors_pl(values):
                            norm = plt.Normalize(min(values), max(values))
                            colorscale = pc.get_colorscale('Picnic')

                            def get_interpolated_color(value):
                                scaled_value = norm(value)

                                for i in range(1, len(colorscale)):
                                    low_pos, low_color = colorscale[i - 1]
                                    high_pos, high_color = colorscale[i]

                                    # Ensure positions are treated as floats
                                    low_pos = float(low_pos)
                                    high_pos = float(high_pos)

                                    if low_pos <= scaled_value <= high_pos:
                                        return pc.find_intermediate_color(
                                            lowcolor=low_color,
                                            highcolor=high_color,
                                            intermed=(scaled_value - low_pos)
                                            / (high_pos - low_pos),
                                            colortype='rgb',
                                        )

                                # Return the last color if value exceeds the colorscale range
                                return colorscale[-1][1]

                            return [get_interpolated_color(value) for value in values]

                        # Function to convert RGBA to hex
                        def rgba_to_hex(rgba):
                            return f'#{int(rgba[0]*255):02x}{int(rgba[1]*255):02x}{int(rgba[2]*255):02x}'

                        # Function to create a scatter plot with text annotations and color gradient boxes
                        def create_plot(x_coords, y_coords, values, title):
                            colors = get_colors_pl(values)
                            # hex_colors = [rgba_to_hex(color) for color in colors]

                            fig = go.Figure()

                            # Define the circle's center and radius
                            circle_center_x = 0  # sum(x_coords) / len(
                            # x_coords
                            # )  # Center of x_coords
                            circle_center_y = 0  # sum(y_coords) / len(
                            # y_coords
                            # )  # Center of y_coords
                            circle_radius = self.wafer_diameter/2
                            # (
                            #     1
                            #     + max(
                            #         max(x_coords) - min(x_coords),
                            #         max(y_coords) - min(y_coords),
                            #     )
                            #     / 2
                            # )

                            # Add the circle to the plot
                            fig.add_shape(
                                type='circle',
                                xref='x',
                                yref='y',
                                x0=circle_center_x - circle_radius,
                                y0=circle_center_y - circle_radius,
                                x1=circle_center_x + circle_radius,
                                y1=circle_center_y + circle_radius,
                                line=dict(color='darkgrey', width=2),
                                fillcolor='grey',
                                opacity=0.3,
                            )

                            for x, y, value, color in zip(
                                x_coords,
                                y_coords,
                                values,
                                colors,  # hex_colors
                            ):
                                if title == 'Tilt Direction':
                                    text_format = f'{float(value):.1f}'
                                else:
                                    text_format = f'{float(value):.3f}'

                                # Adding box around the text with color gradient
                                grid_size=self.grid_size
                                fig.add_shape(
                                    type='rect',
                                    x0=x - grid_size/2,
                                    y0=y - grid_size/2,
                                    x1=x + grid_size/2,
                                    y1=y + grid_size/2,
                                    line=dict(color=color, width=2),
                                    fillcolor=color,
                                    opacity=1,
                                )
                                # fig.add_trace(
                                #     go.Scatter(
                                #         x=[x],
                                #         y=[y],
                                #         mode='text',
                                #         # marker=dict(
                                #         #    size=0,
                                #         # ),
                                #         text=text_format,  # [f'{float(value):.3f}'],
                                #         textfont=dict(
                                #             size=12,  # Font size
                                #             color='black',  # Font color
                                #             family='Arial',  # Font family
                                #             weight='bold',  # Font weight for bold text
                                #         ),
                                #         textposition='middle center',
                                #         showlegend=False,
                                #     )
                                # )
                                # Add text annotation on top of the colored box
                                fig.add_annotation(
                                    x=x,
                                    y=y,
                                    text=text_format,
                                    showarrow=False,
                                    font=dict(color='black', size=12),
                                    xanchor='center',
                                    yanchor='middle',
                                )

                            # Add color bar
                            fig.add_trace(
                                go.Scatter(
                                    x=x_coords,
                                    y=y_coords,
                                    mode='markers',
                                    opacity=0,
                                    marker=dict(
                                        size=0,  # Hide the markers
                                        color=values,
                                        colorscale='Picnic',  # Choose a colorscale
                                        colorbar=dict(
                                            title='',
                                            titleside='right',
                                        ),
                                    ),
                                    showlegend=False,
                                )
                            )
                            fig.update_layout(
                                title=title,
                                xaxis_title='X Position',
                                yaxis_title='Y Position',
                                plot_bgcolor='white',
                                xaxis=dict(
                                    showgrid=True,
                                    zeroline=False,
                                    # scaleanchor='y',
                                    # scaleratio=1,
                                ),
                                yaxis=dict(
                                    showgrid=True,
                                    zeroline=False,
                                    scaleanchor='x',
                                    scaleratio=1,
                                ),
                                hovermode='closest',
                                dragmode='zoom',
                            )
                            return fig

                        def create_stereographic_projection_plot(
                            x_coords, y_coords, tilt, tilt_direction, title
                        ):
                            fig = go.Figure()

                            # Define the circle's center and radius
                            circle_center_x = sum(x_coords) / len(
                                x_coords
                            )  # Center of x_coords
                            circle_center_y = sum(y_coords) / len(
                                y_coords
                            )  # Center of y_coords
                            circle_radius = (
                                3
                                + max(
                                    max(x_coords) - min(x_coords),
                                    max(y_coords) - min(y_coords),
                                )
                                / 2
                            )

                            # Add the circle to the plot
                            fig.add_shape(
                                type='circle',
                                xref='x',
                                yref='y',
                                x0=circle_center_x - circle_radius,
                                y0=circle_center_y - circle_radius,
                                x1=circle_center_x + circle_radius,
                                y1=circle_center_y + circle_radius,
                                line=dict(color='darkgrey', width=2),
                                fillcolor='grey',
                                opacity=0.3,
                            )

                            for x, y, rho, theta in zip(
                                x_coords,
                                y_coords,
                                tilt,
                                tilt_direction,  # hex_colors
                            ):
                                fig.add_shape(
                                    type='rect',
                                    x0=x - 1.5,
                                    y0=y - 1.5,
                                    x1=x + 1.5,
                                    y1=y + 1.5,
                                    line=dict(color='grey', width=2),
                                    fillcolor='white',
                                    opacity=0,
                                )
                                # Add text annotation on top of the colored box
                                # fig.add_annotation(
                                #     x=x,
                                #     y=y,
                                #     text=text_format,
                                #     showarrow=False,
                                #     font=dict(color='black', size=12),
                                #     xanchor='center',
                                #     yanchor='middle',
                                # )

                                # Loop through each coordinate and plot its stereographic projection
                                # for x, y, rho, theta in zip(x_coords, y_coords, rhos, thetas):
                                # Convert polar to Cartesian coordinates for the projection
                                scaling_factor = 15

                                scaled_rho = rho * scaling_factor
                                x_projection = x + scaled_rho * np.cos(
                                    np.radians(theta)
                                )
                                y_projection = y + scaled_rho * np.sin(
                                    np.radians(theta)
                                )
                                # fig.add_shape(
                                #     type='line',
                                #     x0=x,
                                #     y0=y,
                                #     x1=x_projection,
                                #     y1=y_projection,
                                #     line=dict(color='RoyalBlue', width=3),
                                #     xref='x',
                                #     yref='y',
                                #     arrowhead=2,
                                #     arrowsize=1.5,
                                # )

                                # Add a line from (x, y) to the projected point
                                fig.add_trace(
                                    go.Scatter(
                                        x=[x, x_projection],
                                        y=[y, y_projection],
                                        mode='lines+markers',
                                        # marker=dict(size=8),
                                        marker=dict(
                                            symbol='arrow',
                                            size=15,
                                            angleref='previous',
                                        ),
                                        customdata=[
                                            [x, y, rho, theta]
                                        ],  # Include custom data for hover
                                        hovertemplate=(
                                            'X: %{customdata[0]}<br>'
                                            + 'Y: %{customdata[1]}<br>'
                                            + 'Tilt Angle: %{customdata[2]:.3f}<br>'
                                            + 'Tilt Direction: %{customdata[3]:.1f}°<br>'
                                            #  + '<extra></extra>'  # Remove the secondary box
                                        ),
                                        name=f'Point ({x},{y})',
                                    )
                                )

                                # Layout settings
                                # fig.update_layout(
                                #     title='Map of Stereographic Projections on a Wafer',
                                #     xaxis=dict(title='X Coordinate'),
                                #     yaxis=dict(title='Y Coordinate'),
                                #     showlegend=True,
                                #     #width=800,
                                #     #height=800
                                # )

                            fig.update_layout(
                                title=title,
                                xaxis_title='X Position',
                                yaxis_title='Y Position',
                                plot_bgcolor='white',
                                showlegend=False,
                                # width=800,
                                # height=800
                                xaxis=dict(
                                    showgrid=True,
                                    zeroline=False,
                                    # scaleanchor='y',
                                    # scaleratio=1,
                                ),
                                yaxis=dict(
                                    showgrid=True,
                                    zeroline=False,
                                    scaleanchor='x',
                                    scaleratio=1,
                                ),
                            )
                            return fig

                        def create_stereographic_projection_plot_cartesian(
                            x_coords,
                            y_coords,
                            tilt,
                            tilt_direction,
                            component_0_values,
                            component_90_values,
                            title,
                        ):
                            fig = go.Figure()

                            # Define the circle's center and radius
                            circle_center_x = 0  # sum(x_coords) / len(
                            # x_coords
                            # )  # Center of x_coords
                            circle_center_y = 0  # sum(y_coords) / len(
                            # y_coords
                            # )  # Center of y_coords
                            circle_radius = (
                                3
                                + max(
                                    max(x_coords) - min(x_coords),
                                    max(y_coords) - min(y_coords),
                                )
                                / 2
                            )

                            # Add the circle to the plot
                            fig.add_shape(
                                type='circle',
                                xref='x',
                                yref='y',
                                x0=circle_center_x - circle_radius,
                                y0=circle_center_y - circle_radius,
                                x1=circle_center_x + circle_radius,
                                y1=circle_center_y + circle_radius,
                                line=dict(color='darkgrey', width=2),
                                fillcolor='grey',
                                opacity=0.3,
                            )

                            for x, y, rho, theta, comp0, comp90 in zip(
                                x_coords,
                                y_coords,
                                tilt,
                                tilt_direction,  # hex_colors
                                component_0_values,
                                component_90_values,
                            ):
                                fig.add_shape(
                                    type='rect',
                                    x0=x - 1.5,
                                    y0=y - 1.5,
                                    x1=x + 1.5,
                                    y1=y + 1.5,
                                    line=dict(color='grey', width=2),
                                    fillcolor='white',
                                    opacity=0,
                                )
                                # Add text annotation on top of the colored box
                                # fig.add_annotation(
                                #     x=x,
                                #     y=y,
                                #     text=text_format,
                                #     showarrow=False,
                                #     font=dict(color='black', size=12),
                                #     xanchor='center',
                                #     yanchor='middle',
                                # )

                                # Loop through each coordinate and plot its stereographic projection
                                # for x, y, rho, theta in zip(x_coords, y_coords, rhos, thetas):
                                # Convert polar to Cartesian coordinates for the projection
                                scaling_factor = 15

                                # scaled_rho = rho * scaling_factor
                                x_projection = x + (comp0 * scaling_factor * (-1))
                                y_projection = y + (comp90 * scaling_factor)
                                # fig.add_shape(
                                #     type='line',
                                #     x0=x,
                                #     y0=y,
                                #     x1=x_projection,
                                #     y1=y_projection,
                                #     line=dict(color='RoyalBlue', width=3),
                                #     xref='x',
                                #     yref='y',
                                #     arrowhead=2,
                                #     arrowsize=1.5,
                                # )

                                # Add a line from (x, y) to the projected point
                                fig.add_trace(
                                    go.Scatter(
                                        x=[x, x_projection],
                                        y=[y, y_projection],
                                        mode='lines+markers',
                                        # marker=dict(size=8),
                                        marker=dict(
                                            symbol='arrow',
                                            size=15,
                                            angleref='previous',
                                            color='blue',
                                        ),
                                        customdata=[
                                            [
                                                x,
                                                y,
                                                rho,
                                                theta,
                                                x_projection,
                                                y_projection,
                                            ]
                                        ],  # Include custom data for hover
                                        hovertemplate=(
                                            'X: %{customdata[0]}<br>'
                                            + 'Y: %{customdata[1]}<br>'
                                            + 'Tilt Angle: %{customdata[2]:.3f}<br>'
                                            + 'Tilt Direction: %{customdata[3]:.1f}°<br>'
                                            + 'x proj: %{customdata[4]:.1f}°<br>'
                                            + 'y proj: %{customdata[5]:.1f}°<br>'
                                            #  + '<extra></extra>'  # Remove the secondary box
                                        ),
                                        name=f'Point ({x},{y})',
                                    )
                                )

                                # Layout settings
                                # fig.update_layout(
                                #     title='Map of Stereographic Projections on a Wafer',
                                #     xaxis=dict(title='X Coordinate'),
                                #     yaxis=dict(title='Y Coordinate'),
                                #     showlegend=True,
                                #     #width=800,
                                #     #height=800
                                # )

                            fig.update_layout(
                                title=title,
                                xaxis_title='X Position',
                                yaxis_title='Y Position',
                                plot_bgcolor='white',
                                showlegend=False,
                                # width=800,
                                # height=800
                                xaxis=dict(
                                    showgrid=True,
                                    zeroline=False,
                                    # scaleanchor='y',
                                    # scaleratio=1,
                                ),
                                yaxis=dict(
                                    showgrid=True,
                                    zeroline=False,
                                    scaleanchor='x',
                                    scaleratio=1,
                                ),
                            )
                            return fig

                        def create_stereographic_projection_plot_cartesian2(
                            x_coords,
                            y_coords,
                            tilt,
                            tilt_direction,
                            component_0_values,
                            component_90_values,
                            title,
                        ):
                            fig = go.Figure()

                            # Define the circle's center and radius
                            circle_center_x = 0
                            circle_center_y = 0
                            circle_radius = (
                                3
                                + max(
                                    max(x_coords) - min(x_coords),
                                    max(y_coords) - min(y_coords),
                                )
                                / 2
                            )

                            # Add the circle to the plot
                            fig.add_shape(
                                type='circle',
                                xref='x',
                                yref='y',
                                x0=circle_center_x - circle_radius,
                                y0=circle_center_y - circle_radius,
                                x1=circle_center_x + circle_radius,
                                y1=circle_center_y + circle_radius,
                                line=dict(color='darkgrey', width=2),
                                fillcolor='grey',
                                opacity=0.3,
                            )

                            # Loop through each coordinate and plot its stereographic projection as an arrow
                            for x, y, rho, theta, comp0, comp90 in zip(
                                x_coords,
                                y_coords,
                                tilt,
                                tilt_direction,
                                component_0_values,
                                component_90_values,
                            ):
                                fig.add_shape(
                                    type='rect',
                                    x0=x - 1.5,
                                    y0=y - 1.5,
                                    x1=x + 1.5,
                                    y1=y + 1.5,
                                    line=dict(color='grey', width=2),
                                    fillcolor='white',
                                    opacity=0,
                                )

                                # Scaling factor for the projection
                                scaling_factor = 15

                                # Calculate projection points based on comp0 and comp90
                                x_projection = x + (comp0 * scaling_factor * (-1))
                                y_projection = y + (comp90 * scaling_factor)

                                # Add a line from (x, y) to the projected point
                                fig.add_trace(
                                    go.Scatter(
                                        x=[x, x_projection],
                                        y=[y, y_projection],
                                        mode='lines',
                                        line=dict(color='blue', width=2),
                                        showlegend=False,
                                    )
                                )

                                # Add the origin point with hover info
                                fig.add_trace(
                                    go.Scatter(
                                        x=[x],
                                        y=[y],
                                        mode='markers',
                                        marker=dict(
                                            symbol='circle',
                                            size=10,
                                            color='blue',
                                        ),
                                        customdata=[
                                            [x, y, rho, theta]
                                        ],  # Include custom data for hover at origin
                                        hovertemplate=(
                                            'X: %{customdata[0]}<br>'
                                            'Y: %{customdata[1]}<br>'
                                            'Tilt Angle: %{customdata[2]:.3f}<br>'
                                            'Tilt Direction: %{customdata[3]:.1f}°<br>'
                                            '<extra></extra>'
                                        ),
                                        showlegend=False,
                                    )
                                )

                                # Add the tip point with the same hover info
                                fig.add_trace(
                                    go.Scatter(
                                        x=[x_projection],
                                        y=[y_projection],
                                        mode='markers',
                                        marker=dict(
                                            symbol='arrow',
                                            size=15,
                                            color='blue',
                                        ),
                                        customdata=[
                                            [
                                                x,
                                                y,
                                                rho,
                                                theta,
                                                x_projection,
                                                y_projection,
                                            ]
                                        ],  # Hover data
                                        hovertemplate=(
                                            'X: %{customdata[0]}<br>'
                                            'Y: %{customdata[1]}<br>'
                                            'Tilt Angle: %{customdata[2]:.3f}<br>'
                                            'Tilt Direction: %{customdata[3]:.1f}°<br>'
                                            'X Projection: %{customdata[4]:.1f}<br>'
                                            'Y Projection: %{customdata[5]:.1f}<br>'
                                            '<extra></extra>'
                                        ),
                                        showlegend=False,
                                    )
                                )

                            fig.update_layout(
                                title=title,
                                xaxis_title='X Position',
                                yaxis_title='Y Position',
                                plot_bgcolor='white',
                                showlegend=False,
                                xaxis=dict(
                                    showgrid=True,
                                    zeroline=False,
                                ),
                                yaxis=dict(
                                    showgrid=True,
                                    zeroline=False,
                                    scaleanchor='x',
                                    scaleratio=1,
                                ),
                            )
                            return fig

                        def create_stereographic_projection_quiver_plot(
                            x_coords,
                            y_coords,
                            tilt_values,
                            tilt_direction_values,
                            component_0_values,
                            component_90_values,
                            title,
                            wafer_diameter=25,  # Default wafer diameter
                        ):
                            # Compute the u and v components
                            u = [-comp0 for comp0 in component_0_values]  # Inverted x-component
                            v = [comp90 for comp90 in component_90_values]  # y-component

                            # Create hover text
                            hovertext = [
                                f'X: {x}<br>Y: {y}<br>Tilt: {tilt:.3f}<br>Direction: {tilt_dir:.1f}°'
                                for x, y, tilt, tilt_dir in zip(
                                    x_coords, y_coords, tilt_values, tilt_direction_values
                                )
                            ]

                            # Define slider steps and frames
                            steps = []
                            frames = []
                            scales = np.linspace(1, 20, 20)  # Range of scale values for the slider

                            for i, scale in enumerate(scales):
                                # Create quiver plot for each scale
                                quiver = ff.create_quiver(
                                    x_coords,
                                    y_coords,
                                    u,
                                    v,
                                    scale=scale,
                                    arrow_scale=0.2,
                                    name="Tilt Direction",
                                    hoverinfo="text",
                                    text=hovertext,
                                )
                                # Add frame for the current scale
                                frames.append(dict(data=quiver.data, name=f"frame{i}"))

                                # Add a step to the slider
                                step = dict(
                                    method="animate",
                                    args=[
                                        [f"frame{i}"],  # The frame name to animate to
                                        dict(frame=dict(duration=0, redraw=True), mode="immediate"),
                                    ],
                                    label=f"{scale:.1f}",
                                )
                                steps.append(step)

                            # Create the initial quiver plot with the first scale
                            initial_scale = scales[0]
                            fig = ff.create_quiver(
                                x_coords,
                                y_coords,
                                u,
                                v,
                                scale=initial_scale,
                                arrow_scale=0.2,
                                name="Tilt Direction",
                                hoverinfo="text",
                                text=hovertext,
                            )

                            # Add the circle representing the wafer
                            circle_center_x = 0
                            circle_center_y = 0
                            circle_radius = wafer_diameter / 2

                            fig.add_shape(
                                type="circle",
                                xref="x",
                                yref="y",
                                x0=circle_center_x - circle_radius,
                                y0=circle_center_y - circle_radius,
                                x1=circle_center_x + circle_radius,
                                y1=circle_center_y + circle_radius,
                                line=dict(color="darkgrey", width=2),
                                fillcolor="grey",
                                opacity=0.3,
                            )

                            # Add frames and slider to the figure
                            fig.frames = frames
                            sliders = [
                                dict(
                                    steps=steps,
                                    active=0,
                                    currentvalue={"prefix": "Scale: "},
                                )
                            ]

                            # Update the layout to include the slider
                            fig.update_layout(
                                sliders=sliders,
                                title=title,
                                xaxis_title="X Position",
                                yaxis_title="Y Position",
                                plot_bgcolor="white",
                                showlegend=False,
                                xaxis=dict(showgrid=True, zeroline=False, fixedrange=False),
                                yaxis=dict(
                                    showgrid=True,
                                    zeroline=False,
                                    scaleanchor="x",
                                    scaleratio=1,
                                    fixedrange=False,
                                ),
                                hovermode="closest",
                                dragmode="zoom",
                            )

                            return fig



                        def create_stereographic_projection_quiver_plot_alt(
                            x_coords,
                            y_coords,
                            tilt_values,
                            tilt_direction_values,
                            component_0_values,
                            component_90_values,
                            title,
                            #scaling_factor=1,
                        ):
                            # Use quiver to plot arrows from the positions defined by x_coords and y_coords
                            # u (x-component) is component_0_values, v (y-component) is component_90_values
                            u = [
                                -comp0  for comp0 in component_0_values
                            ]  # Inverted x-component
                            v = [
                                comp90 
                                for comp90 in component_90_values
                            ]  # y-component

                            hovertext = [
                                f'X: {x}<br>Y: {y}<br>Tilt: {tilt:.3f}<br>Direction: {tilt_dir:.1f}°'
                                for x, y, tilt, tilt_dir in zip(
                                    x_coords,
                                    y_coords,
                                    tilt_values,
                                    tilt_direction_values,
                                )
                            ]

                            # Create quiver plot
                            if self.wafer_diameter>=25:
                                scaling=15
                            elif self.wafer_diameter <=10:
                                scaling=2
                            fig = ff.create_quiver(
                                x_coords,
                                y_coords,
                                u,
                                v,
                                scale=scaling,
                                arrow_scale=0.2,
                                name='Tilt Direction',
                                hoverinfo='text',
                                text=hovertext,  # Add hover text for each arrow
                            )
                            # Define the circle's center and radius
                            circle_center_x = 0
                            circle_center_y = 0
                            circle_radius = self.wafer_diameter/2

                            # Add the circle to the plot
                            fig.add_shape(
                                type='circle',
                                xref='x',
                                yref='y',
                                x0=circle_center_x - circle_radius,
                                y0=circle_center_y - circle_radius,
                                x1=circle_center_x + circle_radius,
                                y1=circle_center_y + circle_radius,
                                line=dict(color='darkgrey', width=2),
                                fillcolor='grey',
                                opacity=0.3,
                            )

                            # Add layout settings
                            fig.update_layout(
                                title=title,
                                xaxis_title='X Position',
                                yaxis_title='Y Position',
                                plot_bgcolor='white',
                                showlegend=False,
                                xaxis=dict(
                                    showgrid=True,
                                    zeroline=False,
                                    fixedrange=False,
                                ),
                                yaxis=dict(
                                    showgrid=True,
                                    zeroline=False,
                                    scaleanchor='x',  # Make sure x and y are on the same scale
                                    scaleratio=1,
                                    fixedrange=False,
                                ),
                                hovermode='closest',
                                dragmode='zoom',
                            )

                            return fig

                        # Creating plots for each parameter
                        fig_tilt = create_plot(x_coords, y_coords, tilt_values, 'Tilt')
                        fig_tilt_direction = create_plot(
                            x_coords, y_coords, tilt_direction_values, 'Tilt Direction'
                        )
                        fig_component_0 = create_plot(
                            x_coords, y_coords, component_0_values, 'Component 0'
                        )
                        fig_component_90 = create_plot(
                            x_coords, y_coords, component_90_values, 'Component 90'
                        )
                        fig_reference_offset = create_plot(
                            x_coords,
                            y_coords,
                            reference_offset_values,
                            'Reference Offset',
                        )
                        # fig_ster_proj_cart = (
                        #     create_stereographic_projection_plot_cartesian(
                        #         x_coords,
                        #         y_coords,
                        #         tilt_values,
                        #         tilt_direction_values,
                        #         component_0_values,
                        #         component_90_values,
                        #         'cartesian',
                        #     )
                        # )
                        # fig_stereo = create_stereographic_projection_plot(
                        #     x_coords,
                        #     y_coords,
                        #     tilt_values,
                        #     tilt_direction_values,
                        #     'Stereographic Projection',
                        # )
                        fig_quiver = create_stereographic_projection_quiver_plot(
                            x_coords,
                            y_coords,
                            tilt_values,
                            tilt_direction_values,
                            component_0_values,
                            component_90_values,
                            'Stereographic Projection',
                            wafer_diameter=self.wafer_diameter,
                        )
                        fig_quiver_alt = create_stereographic_projection_quiver_plot_alt(
                            x_coords,
                            y_coords,
                            tilt_values,
                            tilt_direction_values,
                            component_0_values,
                            component_90_values,
                            'Stereographic Projection',
                        )
                        # Displaying the plots
                        # fig_tilt.show()
                        # fig_tilt_direction.show()
                        # fig_component_0.show()
                        self.figures = []
                        self.figures.append(self.generate_table_plot())
                        self.figures.append(
                            PlotlyFigure(
                                label='tilt',  # index=1,
                                figure=fig_tilt.to_plotly_json(),
                            )
                        )
                        self.figures.append(
                            PlotlyFigure(
                                label='tilt direction',
                                # index=2,
                                figure=fig_tilt_direction.to_plotly_json(),
                            )
                        )
                        self.figures.append(
                            PlotlyFigure(
                                label='component 0',
                                # index=3,
                                figure=fig_component_0.to_plotly_json(),
                            )
                        )
                        self.figures.append(
                            PlotlyFigure(
                                label='component 90',
                                # index=4,
                                figure=fig_component_90.to_plotly_json(),
                            )
                        )
                        self.figures.append(
                            PlotlyFigure(
                                label='reference offset',
                                # index=5,
                                figure=fig_reference_offset.to_plotly_json(),
                            )
                        )
                        # self.figures.append(
                        #     PlotlyFigure(
                        #         label='stereographic projection',
                        #         # index=6,
                        #         figure=fig_stereo.to_plotly_json(),
                        #     )
                        # )
                        # self.figures.append(
                        #     PlotlyFigure(
                        #         label='cartesian',
                        #         # index=7,
                        #         figure=fig_ster_proj_cart.to_plotly_json(),
                        #     )
                        # )
                        self.figures.append(
                            PlotlyFigure(
                                label='Stereographic Projection',
                                # index=8,
                                figure=fig_quiver.to_plotly_json(),
                            )
                        )
                        self.figures.append(
                            PlotlyFigure(
                                label='Stereographic Projection',
                                # index=8,
                                figure=fig_quiver_alt.to_plotly_json(),
                            )
                        )

        if not self.results:
            return
        # figure1 = px.line(
        #     x=self.results[0].Scan_Curves[0].omega,
        #     y=self.results[0].Scan_Curves[0].intensity,
        #     title='Raman Spectrum',
        #     labels={
        #         'x': 'Wavenumber [1/cm]',
        #         'y': 'Intensity [a.u.]',
        #         'species': 'Species of Iris',
        #     },
        # )
        # self.figures.append(
        #     PlotlyFigure(label='figure 1', index=1, figure=figure1.to_plotly_json())
        # )
        super().normalize(archive, logger)


m_package.__init_metainfo__()
